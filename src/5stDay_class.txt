1. procedure 실습용 테이블

CREATE TABLE userTbl -- 회원 테이블
( userID  	VARCHAR(8) NOT NULL PRIMARY KEY, -- 사용자아이디
  name    	VARCHAR(10) NOT NULL, -- 이름
  birthYear INT NOT NULL,  -- 출생년도
  addr	  	VARCHAR(2) NOT NULL, -- 지역(경기,서울,경남 식으로 2글자만입력)
  mobile1	VARCHAR(3), -- 휴대폰의 국번(011, 016, 017, 018, 019, 010 등)
  mobile2	VARCHAR(8), -- 휴대폰의 나머지 전화번호(하이픈제외)
  height    	SMALLINT,  -- 키
  mDate    	DATE  -- 회원 가입일
);

CREATE TABLE buyTbl -- 회원 구매 테이블
(  num 		INT AUTO_INCREMENT NOT NULL PRIMARY KEY, -- 순번(PK)
   userID  	VARCHAR(8) NOT NULL, -- 아이디(FK)
   prodName 	VARCHAR(6) NOT NULL, --  물품명
   groupName 	VARCHAR(4)  , -- 분류
   price     	INT  NOT NULL, -- 단가
   amount    	SMALLINT  NOT NULL, -- 수량
   FOREIGN KEY (userID) REFERENCES userTbl(userID)
);

INSERT INTO userTbl VALUES('LSG', '이승기', 1987, '서울', '010', '1111111', 182, '2008-8-8');
INSERT INTO userTbl VALUES('KBS', '김범수', 1979, '경남', '010', '2222222', 173, '2012-4-4');
INSERT INTO userTbl VALUES('KKH', '김경호', 1971, '전남', '010', '3333333', 177, '2007-7-7');
INSERT INTO userTbl VALUES('JYP', '조용필', 1950, '경기', '010', '4444444', 166, '2009-4-4');
INSERT INTO userTbl VALUES('SSK', '성시경', 1979, '서울', NULL  , NULL      , 186, '2013-12-12');
INSERT INTO userTbl VALUES('LJB', '임재범', 1963, '서울', '010', '6666666', 182, '2009-9-9');
INSERT INTO userTbl VALUES('YJS', '윤종신', 1969, '경남', 010  , NULL      , 170, '2005-5-5');
INSERT INTO userTbl VALUES('EJW', '은지원', 1972, '경북', '010', '8888888', 174, '2014-3-3');
INSERT INTO userTbl VALUES('JKW', '조관우', 1965, '경기', '010', '9999999', 172, '2010-10-10');
INSERT INTO userTbl VALUES('BBK', '바비킴', 1973, '서울', '010', '0000000', 176, '2013-5-5');

INSERT INTO buyTbl VALUES(NULL, 'KBS', '운동화', NULL   , 30,   2);
INSERT INTO buyTbl VALUES(NULL, 'KBS', '노트북', '전자', 1000, 1);
INSERT INTO buyTbl VALUES(NULL, 'JYP', '모니터', '전자', 200,  1);
INSERT INTO buyTbl VALUES(NULL, 'BBK', '모니터', '전자', 200,  5);
INSERT INTO buyTbl VALUES(NULL, 'KBS', '청바지', '의류', 50,   3);
INSERT INTO buyTbl VALUES(NULL, 'BBK', '메모리', '전자', 80,  10);
INSERT INTO buyTbl VALUES(NULL, 'SSK', '책'    , '서적', 15,   5);
INSERT INTO buyTbl VALUES(NULL, 'EJW', '책'    , '서적', 15,   2);
INSERT INTO buyTbl VALUES(NULL, 'EJW', '청바지', '의류', 50,   1);
INSERT INTO buyTbl VALUES(NULL, 'BBK', '운동화', NULL   , 30,   2);
INSERT INTO buyTbl VALUES(NULL, 'EJW', '책'    , '서적', 15,   1);
INSERT INTO buyTbl VALUES(NULL, 'BBK', '운동화', NULL   , 30,   2);


2. 스토어드 프로시저
   2.1 개요
        - 쿼리문의 집합으로 어떠한 동작을 처리하기 위한 용도로 사용됨.
        - 재사용, 모듈화 개발을 위해서 많이 사용됨.

   2.2 특징
        - Mysql 의 성능을 향상시킬 수 있음.
          몇 백 라인의 sql 문장인 문자열을 네트워크를 경유해서 Mysql 서버로 전송을 하면,
          네트워크의 부하가 발생. 서버도 수신된 SQL 문자을 검사를 하게 됨.

          이러한 기능을 하는 sql을 쿼리문 집합으로 만들어서 스토어드 프로시저라는 객체로
          사용을 하게 되면, 문자열 전송이 없어지고, 장문의 SQL 문자을 검사할 필요가 
          없음. 따라서, 네트워크 부하와 서버의 성능이 높아지게 됨.

        - 유지관가 간편해짐.
          백엔드에서 JAVA 와 관련된 부분에 SQL 문장이 없어지고, 대신에
          스토어드 프로시저를 호출해서 사용하게 됨. 따라서, 함수처럼 호출해서 사용.

          현재 JAVA 의 백엔드 단에 sql 작성해서 운영중인데, sql 문장에 칼럼 추가,
          where 문장을 수정해야 함. => 수정, 테스트, 빌드, 배포 가 발생하게 됨.

          스토어드 프로시저를 사용하게 되면, JAVA 단에서 크게 수정할 부분이 없어짐.
          MYSQL의 스토어드 프로시저 내의 SQL 문장을 수정하면 됨.

        - 모듈식 프로그래밍이 가능해짐.
          함수처럼 사용할 수 있기 때문에, 다른 프로시저에서도 호출해서 사용 가능.

        - 보안을 강화할 수 있음.
          table에 직접 select 하는 것은 경우에 따라서 보안에 좋지 않음.
          그래서, view 를 만들어서 사용하는것으로 함.

          스토어드 프로시저를 이용해서 권한에 맞게끔 select 문장을 작성해두면 됨.

   2.3 형식
        delimiter $$
        create procedure 프로시저 명 ( 매개변수 )
        begin
          SQL 및 반복문 및 제어문 
          sql 1번 문장; 
          sql 2번 문장; 
          sql 3번 문장;
        end $$
        delimiter ;

        call 프로시저 명 ( 매개변수 );

   2.4 매개변수
       in  : 입력 매개변수  
       out : 출력 매개변수

       call proTest(10, @retutnVal);
       // 10 : 입력 매개변수
       // @retutnVal : 출력 매개변수

       select @retutnVal;

       